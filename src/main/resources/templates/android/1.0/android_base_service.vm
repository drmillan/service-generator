## 
## SERVICIO - SERVICIO BASE ANDROID 
## 
/**
  ${serviceName}Service
  ${projectName}

  Created by Generator on 19/01/12.
  Copyright (c) 2012 Mobivery. All rights reserved.
  Version: ${version}
*/
package ${packagename}.logic.base;


import ${packagename}.model.dao.*;
import ${packagename}.model.dto.*; 
import ${packagename}.logic.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URLEncoder;
import java.util.Date;

import com.mobivery.utils.HttpClientHelper;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.CookieStore;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.protocol.ClientContext;
#if(${hasDelete})
import org.apache.http.client.methods.HttpDelete;
#end
#if(${hasGet})
import org.apache.http.client.methods.HttpGet;
#end
#if(${hasPost})
import org.apache.http.client.methods.HttpPost;
#end
#if(${hasPut})
import org.apache.http.client.methods.HttpPut;
#end
#if($hasMultipart)
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.ByteArrayBody;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.entity.mime.content.FileBody;

import java.io.File;
import java.io.FileInputStream;
import org.apache.commons.io.IOUtils;
#end
import org.apache.http.entity.StringEntity;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.BasicHttpContext;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import java.util.List;
import java.util.ArrayList;

import org.json.JSONException;
import org.json.JSONObject;


/**
 * Servicio que realiza las llamadas a DAO,
 * Este servicio corresponde con la logica ${serviceName}
 */
public class Base${serviceName}Logic
{

#foreach ($message in $messages)
	private ${message.response.name} ${message.method}LastResponse;
	private Date ${message.method}LastResponseTime;	
#end

#foreach ($message in $messages) 
	/**
	 * Metodo ${message.method}: ${message.description}
#foreach($type in $message.request.fields)
	 * @param ${type.name} ${type.comment}
#end
	 * @returns ${message.response.name} Respuesta del servidor
	 * @throws ${serviceException} Error de comunicacion / datos 
	 */
	 
	public ${message.response.name} ${message.method}(${message.javaRequestParams}) throws ${serviceException}
	{
		
		${message.request.name} ${message.request.javaInstanceName}=new ${message.request.name}();
#foreach($field in $message.request.fields)
		${message.request.javaInstanceName}.set${field.nameUcase}(${field.javaName});	
#end	
		${message.response.name} returnValue=${message.method}(${message.request.javaInstanceName});
		${message.method}LastResponse = returnValue;
		${message.method}LastResponseTime = new Date();
		return returnValue;
	}
	
	/**
	 * Metodo ${message.method}: ${message.description}
	 * @param ${message.request.javaInstanceName} Peticion al servicio
	 * @returns ${message.response.name} Respuesta del servidor
	 * @throws ${serviceException} Error de comunicacion / datos 
	 */
	public ${message.response.name} ${message.method}(${message.request.name} ${message.request.javaInstanceName}) throws ${serviceException}
	{
		try
		{
		CookieStore cookieStore = new BasicCookieStore();	
		HttpContext localContext = new BasicHttpContext();
		localContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
	
		#if($onSend)
			${onSend}(${message.request.javaInstanceName});
		#end
		${message.response.name} ${message.response.javaInstanceName};
		// Obtenemos la URL del mensaje : ${message.url}
		String url="${message.url}";
		url=${projectName}Helper.getInstance().preInjectURLParameters(url,${message.request.javaInstanceName});
#foreach($field in $message.request.fields)
		if(${message.request.javaInstanceName}.get${field.nameUcase}()==null)
		{
			url=url.replace("${${field.name}}","");
		}
		else
		{
			url=url.replace("${${field.name}}",URLEncoder.encode(String.valueOf(${message.request.javaInstanceName}.get${field.nameUcase}()),"UTF-8"));
		}	
#end		
		
		url=fixSystemProperties(url);

		url=url.replace("|",URLEncoder.encode("|","UTF-8"));
		url=${projectName}Helper.getInstance().postInjectURLParameters(url,${message.request.javaInstanceName});
		System.out.println(Base${serviceName}Logic.class.getName()+" SENT:"+url);
		String result;
		#if($message.request.multipart)
		DefaultHttpClient httpClient = HttpClientHelper.getInstance().getNewHttpClient();
		HttpPost postRequest = new HttpPost(url);			
		MultipartEntity reqEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
			
#foreach($field in $message.request.fields)
#if($field.type=='file')
		reqEntity.addPart("${field.name}", new FileBody(new File(String.valueOf(${message.request.javaInstanceName}.get${field.nameUcase}())),"${field.mimeType}"));
#end
#if($field.type!='file')
	 	reqEntity.addPart("$field.name", new StringBody(String.valueOf(${message.request.javaInstanceName}.get${field.nameUcase}())));
#end       
#end
			
		postRequest.setEntity(reqEntity);
		${projectName}Helper.getInstance().preExecute(httpClient,postRequest,cookieStore,localContext);
		HttpResponse response = httpClient.execute(postRequest,localContext);
		${projectName}Helper.getInstance().postExecute(httpClient,postRequest,response,cookieStore);
		BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), "UTF-8"));
		String sResponse;
		StringBuilder s = new StringBuilder();

		while ((sResponse = reader.readLine()) != null) {
			s = s.append(sResponse);
		}
		result=s.toString();
		#end
		#if(!$message.request.multipart)
		DefaultHttpClient client = HttpClientHelper.getInstance().getNewHttpClient();
		Http${message.type.replace("JSON","")} request=new Http${message.type.replace("JSON","")}(url);

#if(${message.type}=='Post' || ${message.type}=='Delete' || ${message.type}=='Put')
		List <NameValuePair> parameters = new ArrayList <NameValuePair>(); 
#foreach($field in $message.request.fields)
	 	parameters.add(new BasicNameValuePair("$field.name", String.valueOf(${message.request.javaInstanceName}.get${field.nameUcase}())));       
#end
#if(${message.type}!='Delete')
		request.setEntity(new UrlEncodedFormEntity(parameters, HTTP.UTF_8));
#end
#end
#if(${message.type}=='PostJSON' || ${message.type}=='DeleteJSON' || ${message.type}=='PutJSON')		
		JSONObject jsonObject = ${message.request.daoName}.getInstance().serialize(${message.request.javaInstanceName});
		StringEntity requestEntity = new StringEntity(jsonObject.toString(), HTTP.UTF_8);
		System.out.println(Base${serviceName}Logic.class.getName()+" SENT (application/json):"+jsonObject.toString());
		requestEntity.setContentType("application/json");
		request.setEntity(requestEntity);
#end
#if (${message.type}=='GetJSON')
		JSONObject jsonObject = ${message.request.daoName}.getInstance().serialize(${message.request.javaInstanceName});
		request.addHeader("data",jsonObject.toString());	
		System.out.println(Base${serviceName}Logic.class.getName()+" SENT (application/json):"+jsonObject.toString());			
#end
        ${projectName}Helper.getInstance().preExecute(client,request,cookieStore,localContext);
		HttpResponse response = client.execute(request,localContext);
		${projectName}Helper.getInstance().postExecute(client,request,response,cookieStore);
		HttpEntity entity = response.getEntity();
		result=convertStreamToString(entity.getContent());
		result=${projectName}Helper.getInstance().preprocessResponse(result);
		
		System.out.println(Base${serviceName}Logic.class.getName()+" RECEIVED:"+result);
		#end
		${message.response.javaInstanceName}=${message.response.daoName}.getInstance().create(new JSONObject(result));
		#if($onReceive)
			${onReceive}(${message.request.javaInstanceName},${message.response.javaInstanceName});
		#end	
		
		${message.method}LastResponse = ${message.response.javaInstanceName};
		${message.method}LastResponseTime = new Date();
		
		return ${message.response.javaInstanceName};
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
			throw new ${serviceException}(ex);
		}
	}
	#end	
	
	/**
	 * Lee el contenido de un stream como una cadena
	 * @param is InputStream del que leer
	 * @return Cadena leida
	 * @throws IOException
	 */
	private String convertStreamToString(InputStream is) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(is));
		StringBuilder sb = new StringBuilder();

		String line = null;
			while ((line = reader.readLine()) != null) {
				sb.append(line + "\n");
			}
		return sb.toString();
	}
	
	/**
	 * A–ade las propiedades de sistema en los par‡metros que aun no tienen valor establecido
	 * @param URL original
	 * @returns URL modificada anyadiendo las propiedades de sistema
	 */
	private  String fixSystemProperties(String url)
	{
		while(url.contains("${"))
		{
			int start=url.indexOf("${")+2;
			int end=url.indexOf("}",start);
			String key=url.substring(start,end);
			String value=System.getProperty(key,"");
			url=url.replace("${"+key+"}",value);
		}
		return url;
	}
	
#foreach ($message in $messages)
	/**
	 * Obtiene la ultima respuesta cacheada de ${message.methodUpperCase}
	 * @returns valor cacheado
	 */
	public ${message.response.name} get${message.methodUpperCase}LastResponse() {
		return ${message.method}LastResponse;
	}

	/**
	 * Obtiene cuando se obtuvo la ultima respuesta cacheada de ${message.methodUpperCase}
	 * @returns ultima actualizacion
	 */	
	public Date get${message.methodUpperCase}LastResponseTime() {
		return ${message.method}LastResponseTime;
	}	
	
#end
}
